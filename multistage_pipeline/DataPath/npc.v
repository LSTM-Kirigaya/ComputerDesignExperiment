module npc (
    Jump, 
    branch, 
    JR,
    zero, 
    pc_add_out,
    EX_MEM_branch_add_out, 
    EX_MEM_instr26, 
    EX_MEM_regfile_out1,
    NPC
    );  
    
    input               Jump;            // whether Jump or not
    input      [ 1: 0]  branch;          // whether enter branch or not  
    input               JR;
    input               zero;            // zero generated by ALU

    input      [31: 0]  pc_add_out;
    input      [31: 0]  EX_MEM_branch_add_out;             
    // input      [31: 0]  EX_MEM_pc_add_out;       // this is actually the PC instead of EX_MEM_pc_add_out, latter is a previous bug
    input      [25: 0]  EX_MEM_instr26;
    input      [31: 0]  EX_MEM_regfile_out1;     // if the real instruction of the cycle is JR, then the signal is the GPR[rs], which is the address stored in the target register

    reg        [31: 0]  PC;

    output reg [31: 0]  NPC;


    always @(*)    
        // judge JR first
        if (JR)
        begin
            NPC = EX_MEM_regfile_out1;
        end
        else if (branch == 2'b01 && zero == 1)        // beq
        begin
            NPC = EX_MEM_branch_add_out; 
        end
        else if (branch == 2'b10 && zero == 0)   // bne
        begin
            NPC = EX_MEM_branch_add_out;
        end
        else if (Jump)              // different to P182, which Jump iff Jump == 0. Here, we do J op iff Jump == 1
        begin    
            PC = pc_add_out - 4;
            NPC = {PC[31:28], {EX_MEM_instr26[25:0] << 2}};
            // $display("Jump!");
        end
        else
        begin
            // $display("enter", "%h", EX_MEM_pc_add_out);
            NPC = pc_add_out;
        end

endmodule //npc 